<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Clash Royale Deck Creator - Drag & Drop + Stats Popup</title>
<style>
  html, body {
    height: 100%;
    margin: 0;
    background: #1e40af; /* blue background */
    font-family: Arial, sans-serif;
    color: #222222;
  }
  body {
    display: flex;
    height: 100vh;
  }
  #main {
    flex: 1;
    display: flex;
    flex-direction: column;
    padding: 15px 20px;
    overflow-y: auto;
  }
  #deck-container {
    border-bottom: 2px solid #daa520;
    padding-bottom: 10px;
    margin-bottom: 15px;
  }
  #deck-container h2 {
    color: #facc15;
    margin: 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  #clear-deck-btn {
    background: #b45309;
    color: #fff;
    border: none;
    padding: 6px 10px;
    border-radius: 6px;
    cursor: pointer;
    font-weight: bold;
    font-size: 14px;
    user-select: none;
    transition: background 0.3s ease;
  }
  #clear-deck-btn:hover {
    background: #78350f;
  }
  #deck {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-top: 10px;
    flex-wrap: wrap;
  }
  /* gradient border for first two slots */
  .deck-slot.first-two {
    border-image: linear-gradient(135deg, purple, gold) 1;
    border-width: 3px;
    border-style: solid;
  }
  .deck-slot.empty {
    border-color: #daa520;
    background-color: #1e3a8a;
  }
  .deck-slot {
    width: 80px;
    height: 110px;
    border: 2px solid #daa520;
    background-color: #1e3a8a; /* darker blue */
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    position: relative;
    user-select: none;
    padding: 4px 0;
  }
  .deck-slot img {
    max-width: 60px;
    max-height: 60px;
    pointer-events: none;
    margin-bottom: 2px;
  }
  .deck-slot .elixir {
    position: absolute;
    top: 4px;
    right: 6px;
    background: gold;
    border-radius: 50%;
    padding: 2px 6px;
    font-weight: bold;
    color: #222;
    font-size: 12px;
  }
  .deck-slot.empty::after {
    content: "Empty";
    color: #daa520;
    font-weight: bold;
    font-size: 14px;
  }

  /* Container for deck slot and stats icon */
  .deck-slot-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2px;
  }
  
  /* Stat icon below the deck slot */
  .deck-slot-container .stats-icon {
    cursor: pointer;
    font-size: 16px;
    color: gold;
    user-select: none;
    text-align: left;
    font-weight: bold;
    background: rgba(0,0,0,0.5);
    padding: 1px 4px;
    border-radius: 3px;
    width: 60px;
    font-size: 11px;
  }

  /* Tower icon next to deck */
  #deck-and-tower {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    margin-top: 10px;
  }
  /* *** CHANGED: tower icon matches slot size (80x110) and same border-radius *** */
  #current-tower-icon {
    width: 80px;
    height: 110px;
    border: 2px solid #daa520;
    border-radius: 8px;
    background: #1e3a8a;
    object-fit: contain;
  }

  /* Average Elixir display at end of deck */
  #average-elixir-display {
    margin-top: 8px;
    text-align: center;
    font-weight: bold;
    font-size: 18px;
    color: purple; /* changed to purple to match card theme */
  }

  /* stacked groups vertically, cards inside group horizontally */
  #cards-list {
    margin-top: 10px;
    display: flex;
    flex-direction: column; /* vertical stack */
    gap: 20px;
  }
  .card-group {
    max-width: 100%;
    display: flex;       /* cards side by side */
    gap: 10px;          /* cards closer horizontally */
    flex-wrap: wrap;     /* wrap cards if needed */
  }
  .card-group h3 {
    width: 100%;
    margin-top: 0;
    border-bottom: 2px solid #daa520;
    padding-bottom: 5px;
    color: #facc15;
  }
  .card {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 8px 0;
    padding: 3px 4px;
    background: white;
    border-radius: 6px;
    box-shadow: 0 0 5px rgb(218 165 32 / 0.5);
    cursor: grab;
    user-select: none;
    transition: background 0.2s ease;
    position: relative;
    width: 65px;
  }
  .card:active {
    cursor: grabbing;
  }
  .card:hover {
    background: #fde68a;
  }
  .card .elixir-cost {
    color: #c71585; /* Darker pink (MediumVioletRed) */
    font-weight: bold;
    font-size: 18px;
    margin-bottom: 2px;
    display: block;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
  }
  .card img {
    width: 50px;
    height: 50px;
    margin: 1px 0;
    pointer-events: none;
    border: 1px solid #ddd;
    border-radius: 4px;
  }
  .card .name {
    margin: 2px 0 0 0;
    font-weight: bold;
    font-size: 8px; /* Decreased by 3 from original 11px */
    text-align: center;
    width: 100%;
    display: block;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    line-height: 1;
  }
  .card-name-container {
    display: flex;
    flex-direction: column;
    width: 100%;
    text-align: center;
  }
  .card-name-main {
    font-size: 11px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .card-name-sub {
    font-size: 11px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    line-height: 1;
  }
  .stats-icon {
    cursor: pointer;
    user-select: none;
    position: absolute;
    top: 2px;
    right: 2px;
    font-size: 16px;
    color: gold;
    text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
  }

  #saved-decks-container {
    width: 320px;
    border-left: 2px solid #daa520;
    padding-left: 15px;
    background: #0f172a;
    color: #facc15;
    overflow-y: auto;
  }
  #saved-decks-container h2 {
    margin-top: 0;
    border-bottom: 2px solid #daa520;
    padding-bottom: 5px;
  }
  #saved-decks {
    margin-top: 10px;
  }
  .saved-deck {
    background: #1e3a8a;
    border-radius: 6px;
    box-shadow: 0 0 8px rgb(218 165 32 / 0.6);
    margin-bottom: 12px;
    padding: 10px;
    position: relative;
    display: flex;
    flex-direction: column; /* make column so tower can be shown below cards */
    gap: 8px;
  }
  .saved-deck-top {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
  }
  .saved-deck-left {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 6px;
  }
  .saved-deck-name {
    font-weight: bold;
    color: #fbbf24;
  }
  .saved-deck-cards-row {
    display: flex;
    flex-wrap: nowrap; /* keep on a single horizontal row; allow overflow if needed */
    gap: 6px;
    overflow-x: auto; /* in case viewport is narrow */
    align-items: center;
  }
  .saved-deck-cards-row img {
    width: 30px;
    height: 30px;
    border: 1px solid #daa520;
    border-radius: 4px;
    flex: 0 0 auto;
  }
  .saved-deck-tower {
    display: flex;
    align-items: center;
    justify-content: flex-start;
    gap: 8px;
    margin-top: 6px;
  }
  .tower-icon {
    width: 36px;
    height: 36px;
    border: 1px solid #daa520;
    border-radius: 6px;
    background: #1e3a8a;
    object-fit: contain;
  }

  .delete-deck-btn {
    position: absolute;
    top: 6px;
    right: 6px;
    background: transparent;
    border: none;
    color: #f87171;
    font-size: 18px;
    cursor: pointer;
    user-select: none;
  }
  .delete-deck-btn:hover {
    color: #b91c1c;
  }
  .edit-deck-btn {
    position: absolute;
    top: 6px;
    right: 34px;
    background: transparent;
    border: none;
    color: #38bdf8; /* bright blue */
    font-size: 18px;
    cursor: pointer;
    user-select: none;
  }
  .edit-deck-btn:hover {
    color: #0ea5e9;
  }

  form {
    margin-top: 12px;
    display: flex;
    gap: 8px;
    align-items: center;
  }
  input[type="text"] {
    flex: 1;
    padding: 6px 8px;
    border-radius: 4px;
    border: 1px solid #daa520;
    font-weight: bold;
    color: #444;
  }
  button[type="submit"] {
    background: #daa520;
    border: none;
    color: #222;
    font-weight: bold;
    padding: 8px 12px;
    border-radius: 6px;
    cursor: pointer;
    transition: background 0.3s ease;
  }
  button[type="submit"]:hover:not(:disabled) {
    background: #b8860b;
  }
  button[type="submit"]:disabled {
    background: #e0c97a;
    cursor: not-allowed;
  }

  select.tower-select {
    padding: 6px 8px;
    border-radius: 4px;
    border: 1px solid #daa520;
    font-weight: bold;
    color: #444;
    background: #fff;
  }

  /* Drag hover highlight */
  .deck-slot.drag-over {
    box-shadow: 0 0 15px 4px gold;
  }
  .card.dragging {
    opacity: 0.5;
  }

  /* Stats Popup */
  #stats-popup-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.75);
    justify-content: center;
    align-items: center;
    z-index: 9999;
  }
  #stats-popup {
    background: #1e3a8a;
    border-radius: 10px;
    padding: 20px;
    width: 280px;
    color: #facc15;
    box-shadow: 0 0 15px gold;
    text-align: center;
  }
  #stats-popup img {
    max-width: 100px;
    max-height: 100px;
    margin-bottom: 10px;
  }
  #stats-popup h3 {
    margin: 5px 0;
  }
  #stats-popup p {
    font-size: 14px;
    margin: 10px 0;
  }
  #stats-popup .elixir-cost {
    font-weight: bold;
    font-size: 16px;
    color: gold;
  }
  #stats-popup-close {
    cursor: pointer;
    background: #daa520;
    border: none;
    border-radius: 6px;
    padding: 6px 12px;
    font-weight: bold;
    margin-top: 10px;
    color: #222;
  }
</style>
</head>
<body>

<div id="main">
  <div id="deck-container">
    <h2>
      Your Deck (8 Cards)
      <button id="clear-deck-btn" title="Clear the deck">Clear Deck</button>
    </h2>

    <!-- deck and tower icon -->
    <div id="deck-and-tower" aria-hidden="false">
      <div id="deck" aria-label="Your deck slots" role="list">
        <!-- 8 slots will be rendered here -->
      </div>
      <!-- Tower icon shown to the right of the deck (starts blank until chosen) -->
      <img id="current-tower-icon" src="" alt="Selected Tower" />
    </div>

    <div id="average-elixir-display" aria-live="polite" aria-atomic="true"></div>
    <form id="save-form" aria-label="Save deck form">
      <input type="text" id="deck-name" placeholder="Enter deck name" maxlength="20" aria-required="true" />
      <!-- tower select: minimal insertion, does not change existing form layout drastically -->
      <select id="tower-select" class="tower-select" aria-label="Choose tower">
        <option value="princess_tower">Princess Tower</option>
        <option value="dagger_duchess">Dagger Duchess</option>
        <option value="canoneer">Canoneer</option>
        <option value="royal_chef">Royal Chef</option>
      </select>
      <button type="submit" disabled>Save Deck</button>
    </form>
  </div>

  <div id="cards-list" aria-label="Available cards">
    <!-- cards grouped by type rendered here -->
  </div>
</div>

<div id="saved-decks-container" aria-live="polite" aria-atomic="true">
  <h2>Saved Decks</h2>
  <div id="saved-decks"></div>
</div>

<!-- Stats Popup -->
<div id="stats-popup-overlay" role="dialog" aria-modal="true" aria-labelledby="stats-popup-title" aria-describedby="stats-popup-desc">
  <div id="stats-popup">
    <img id="stats-popup-img" src="" alt="" />
    <h3 id="stats-popup-title"></h3>
    <p id="stats-popup-desc"></p>
    <div class="elixir-cost">Elixir Cost: <span id="stats-popup-elixir"></span></div>
    <button id="stats-popup-close">Close</button>
  </div>
</div>

<script>
  // === TOWERS: minimal data structure for selectable tower troops ===
  const towers = {
    princess_tower: {
      key: 'princess_tower',
      name: 'Princess Tower',
      img: 'TowerPrincessCard.webp'
    },
    dagger_duchess: {
      key: 'dagger_duchess',
      name: 'Dagger Duchess',
      img: 'DaggerDuchessCard.webp'
    },
    canoneer: {
      key: 'canoneer',
      name: 'Canoneer',
      img: 'CannoneerCard.webp'
    },
    royal_chef: {
      key: 'royal_chef',
      name: 'Royal Chef',
      img: 'RoyalChefCard.webp'
    }
  };

  // === CARDS ARRAY - Only cards with 5 elixir or less ===
  const cards = [
    { key: 'hog_rider', name: 'Hog Rider', elixir: 4, type: 'troop', 
      img: 'HogRiderCard.webp',
      stats: 'Fast building attacker.' },
    { key: 'bandit', name: 'Bandit', elixir: 3, type: 'troop',
      img: 'BanditCard.webp',
      stats: 'Dash damage troop.' },
    { key: 'battle_ram', name: 'Battle Ram', elixir: 4, type: 'troop',
      img: 'BattleRamCard.webp',
      stats: 'Charge to buildings.' },
    { key: 'electro_wizard', name: 'Electro Wizard', elixir: 4, type: 'troop',
      img: 'ElectroWizardCard.webp',
      stats: 'Stuns on spawn and attack.' },
    { key: 'cannon', name: 'Cannon', elixir: 3, type: 'building',
      img: 'CannonCard.webp',
      stats: 'Cheap defensive building.' },
    { key: 'fireball', name: 'Fireball', elixir: 4, type: 'spell',
      img: 'FireballCard.webp',
      stats: 'Area damage spell.' },
    { key: 'zap', name: 'Zap', elixir: 2, type: 'spell',
      img: 'ZapCard.webp',
      stats: 'Stuns and damages small area.' },
    { key: 'mega_minion', name: 'Mega Minion', elixir: 3, type: 'troop',
      img: 'MegaMinionCard.webp',
      stats: 'Flying, medium damage troop.' },
    { key: 'inferno_tower', name: 'Inferno Tower', elixir: 5, type: 'building',
      img: 'InfernoTowerCard-removebg-preview.png',
      stats: 'High damage ramping building.' },
    { key: 'goblinstein', name: 'Goblin-Stein', elixir: 5, type: 'troop',
      img: 'goblinstein.webp',
      stats: 'High damage ramping building.' },
    { key: 'monk', name: 'Monk', elixir: 5, type: 'troop',
      img: 'MonkCard.webp',
      stats: 'High damage ramping building.' },
    { key: 'archer_queen', name: 'Archer Queen', elixir: 5, type: 'troop',
      img: 'ArcherQueenCard.webp',
      stats: 'High damage ramping building.' },
    { key: 'goblin_machine', name: 'Goblin Machine', elixir: 5, type: 'troop',
      img: 'GoblinMachineCard.webp',
      stats: 'High damage ramping building.' },
    { key: 'cannon_cart', name: 'Cannon Cart', elixir: 5, type: 'troop',
      img: 'CannonCartCard.webp',
      stats: 'High damage ramping building.' },
    { key: 'executioner', name: 'Executioner', elixir: 5, type: 'troop',
      img: 'ExecutionerCard.webp',
      stats: 'High damage ramping building.' },
    { key: 'bowler', name: 'Bowler', elixir: 5, type: 'troop',
      img: 'BowlerCard.webp',
      stats: 'High damage ramping building.' },
    { key: 'rascals', name: 'Rascals', elixir: 5, type: 'troop',
      img: 'RascalsCard.webp',
      stats: 'High damage ramping building.' },
    { key: 'graveyard', name: 'Graveyard', elixir: 5, type: 'spell',
      img: 'GraveyardCard.webp',
      stats: 'High damage ramping building.' },
    { key: 'electro_dragon', name: 'Electro Dragon', elixir: 5, type: 'troop',
      img: 'ElectroDragonCard.webp',
      stats: 'High damage ramping building.' },
    { key: 'ram_rider', name: 'Ram Rider', elixir: 5, type: 'troop',
      img: 'RamRiderCard.webp',
      stats: 'High damage ramping building.' },
    { key: 'minion_horde', name: 'Minion Horde', elixir: 5, type: 'troop',
      img: 'MinionHordeCard.webp',
      stats: 'High damage ramping building.' },
    { key: 'prince', name: 'Prince', elixir: 5, type: 'troop',
      img: 'PrinceCard.webp',
      stats: 'High damage ramping building.' },
    { key: 'balloon', name: 'Balloon', elixir: 5, type: 'troop',
      img: 'BalloonCard.webp',
      stats: 'High damage ramping building.' },
    { key: 'royal_hogs', name: 'Royal Hogs', elixir: 5, type: 'troop',
      img: 'RoyalHogsCard.webp',
      stats: 'High damage ramping building.' },
    { key: 'witch', name: 'Witch', elixir: 5, type: 'troop',
      img: 'WitchCard.webp',
      stats: 'High damage ramping building.' },
    { key: 'wizard', name: 'Wizard', elixir: 5, type: 'troop',
      img: 'WizardCard.webp',
      stats: 'High damage ramping building.' },
    { key: 'barbarians', name: 'Barbarians', elixir: 5, type: 'troop',
      img: 'BarbariansCard.webp',
      stats: 'High damage ramping building.' },
    { key: 'giant', name: 'Giant', elixir: 5, type: 'troop',
      img: 'GiantCard.webp',
      stats: 'High damage ramping building.' },
    { key: 'mighty_miner', name: 'Mighty Miner', elixir: 4, type: 'troop',
      img: 'MightyMinerCard.webp',
      stats: 'High damage ramping building.' }
  ];

  // Format long names to have second part below first part
  function formatCardName(name) {
    // Special cases for specific cards
    if (name === 'Goblin-Stein') {
      return {
        main: 'Goblin',
        sub: 'Stein'
      };
    }
    if (name === 'Archer Queen') {
      return {
        main: 'Archer',
        sub: 'Queen'
      };
    }
    if (name === 'Cannon Cart') {
      return {
        main: 'Cannon',
        sub: 'Cart'
      };
    }
    if (name === 'Electro Dragon') {
      return {
        main: 'Electro',
        sub: 'Dragon'
      };
    }
    if (name === 'Ram Rider') {
      return {
        main: 'Ram',
        sub: 'Rider'
      };
    }
    if (name === 'Minion Horde') {
      return {
        main: 'Minion',
        sub: 'Horde'
      };
    }
    if (name === 'Royal Hogs') {
      return {
        main: 'Royal',
        sub: 'Hogs'
      };
    }
    if (name === 'Barbarians') {
      return {
        main: 'Barb-',
        sub: 'arians'
      };
    }
    
    // Default case - just return the full name
    return {
      main: name,
      sub: ''
    };
  }

  // Sort cards by elixir cost instead of alphabetical (lowest elixir first).
  // If elixir is equal, fall back to alphabetical order by name.
  cards.sort((a, b) => {
    if (a.elixir !== b.elixir) return a.elixir - b.elixir;
    return a.name.localeCompare(b.name);
  });

  const deckSlotsCount = 8;
  let deck = new Array(deckSlotsCount).fill(null);
  let savedDecks = JSON.parse(localStorage.getItem('savedDecks') || '[]');

  const deckEl = document.getElementById('deck');
  const cardsListEl = document.getElementById('cards-list');
  const clearDeckBtn = document.getElementById('clear-deck-btn');
  const saveForm = document.getElementById('save-form');
  const deckNameInput = document.getElementById('deck-name');
  const saveBtn = saveForm.querySelector('button[type="submit"]');
  const savedDecksContainer = document.getElementById('saved-decks');
  const averageElixirDisplay = document.getElementById('average-elixir-display');

  // Stats popup elements
  const statsPopupOverlay = document.getElementById('stats-popup-overlay');
  const statsPopupImg = document.getElementById('stats-popup-img');
  const statsPopupTitle = document.getElementById('stats-popup-title');
  const statsPopupDesc = document.getElementById('stats-popup-desc');
  const statsPopupElixir = document.getElementById('stats-popup-elixir');
  const statsPopupCloseBtn = document.getElementById('stats-popup-close');

  // Tower select & icon elements (minimal additions)
  const towerSelect = document.getElementById('tower-select');
  const currentTowerIcon = document.getElementById('current-tower-icon');

  // Initialize current tower icon to selection's default on load
  (function initTowerFromSelect() {
    if (towerSelect && towers[towerSelect.value]) {
      currentTowerIcon.src = towers[towerSelect.value].img;
      currentTowerIcon.alt = towers[towerSelect.value].name;
    } else {
      currentTowerIcon.src = '';
      currentTowerIcon.alt = 'Selected Tower';
    }
  })();

  // Render deck slots (preserve original functionality exactly)
  function renderDeck() {
    deckEl.innerHTML = '';
    for (let i = 0; i < deckSlotsCount; i++) {
      // Create a container for the slot and stats icon
      const container = document.createElement('div');
      container.className = 'deck-slot-container';
      
      const slot = document.createElement('div');
      slot.classList.add('deck-slot');
      if (i < 2) slot.classList.add('first-two'); // gradient border for first 2 slots

      if (!deck[i]) {
        slot.classList.add('empty');
      } else {
        const card = deck[i];
        const img = document.createElement('img');
        img.src = card.img;
        img.alt = card.name;
        slot.appendChild(img);

        const elixirBadge = document.createElement('div');
        elixirBadge.classList.add('elixir');
        elixirBadge.textContent = card.elixir;
        slot.appendChild(elixirBadge);
      }

      slot.dataset.index = i;
      slot.setAttribute('role', 'listitem');
      slot.setAttribute('aria-label', deck[i] ? deck[i].name : 'Empty slot');

      // Drag and drop handlers for swapping/removing cards
      slot.addEventListener('dragover', e => {
        e.preventDefault();
        slot.classList.add('drag-over');
      });
      slot.addEventListener('dragleave', () => {
        slot.classList.remove('drag-over');
      });
      slot.addEventListener('drop', e => {
        e.preventDefault();
        slot.classList.remove('drag-over');
        const type = e.dataTransfer.getData('type');
        if (type === 'card-list') {
          const cardKey = e.dataTransfer.getData('cardKey');
          const cardToAdd = cards.find(c => c.key === cardKey);
          if (!cardToAdd) return;
          // Add card to this slot if empty or swap if occupied
          deck[i] = cardToAdd;
          renderDeck();
          renderCards();
          updateSaveButton();
        } else if (type === 'deck-card') {
          const fromIndex = parseInt(e.dataTransfer.getData('fromIndex'), 10);
          if (fromIndex === i) return;

          // Swap cards between fromIndex and i
          const temp = deck[i];
          deck[i] = deck[fromIndex];
          deck[fromIndex] = temp;
          renderDeck();
          renderCards();
          updateSaveButton();
        }
      });

      // Click on deck slot removes card from deck
      slot.addEventListener('click', () => {
        if (deck[i]) {
          deck[i] = null;
          renderDeck();
          renderCards();
          updateSaveButton();
        }
      });

      // Make deck slots draggable
      slot.setAttribute('draggable', true);
      slot.addEventListener('dragstart', e => {
        if (!deck[i]) {
          e.preventDefault();
          return;
        }
        e.dataTransfer.setData('type', 'deck-card');
        e.dataTransfer.setData('fromIndex', i);
        slot.classList.add('dragging');
      });
      slot.addEventListener('dragend', () => {
        slot.classList.remove('dragging');
      });

      container.appendChild(slot);
      
      // Add stats icon below the slot if there's a card
      if (deck[i]) {
        const statIcon = document.createElement('span');
        statIcon.className = 'stats-icon';
        statIcon.innerHTML = 'Stats';
        statIcon.title = 'View stats';
        statIcon.addEventListener('click', e => {
          e.stopPropagation();
          openStatsPopup(deck[i]);
        });
        container.appendChild(statIcon);
      }

      deckEl.appendChild(container);
    }
    updateAverageElixir();
  }

  // Render cards grouped by type, excluding those already in deck
  function renderCards() {
    cardsListEl.innerHTML = '';
    const groups = { troop: [], spell: [], building: [] };

    deck.forEach(c => { if (c) groups[c.type].push(c.key); });

    ['troop', 'spell', 'building'].forEach(type => {
      const groupCards = cards.filter(c => c.type === type && !groups[type].includes(c.key));
      if (groupCards.length === 0) return;

      const groupDiv = document.createElement('div');
      groupDiv.className = 'card-group';
      const groupTitle = document.createElement('h3');
      groupTitle.textContent = type.charAt(0).toUpperCase() + type.slice(1) + 's';
      groupDiv.appendChild(groupTitle);

      groupCards.forEach(card => {
        const cardDiv = document.createElement('div');
        cardDiv.className = 'card';
        cardDiv.draggable = true;

        // Elixir cost (darker pink, above the card)
        const elixirSpan = document.createElement('span');
        elixirSpan.className = 'elixir-cost';
        elixirSpan.textContent = card.elixir;
        cardDiv.appendChild(elixirSpan);

        const img = document.createElement('img');
        img.src = card.img;
        img.alt = card.name;
        cardDiv.appendChild(img);

        // Card name (below the card)
        const nameContainer = document.createElement('div');
        nameContainer.className = 'card-name-container';
        
        const nameMain = document.createElement('div');
        nameMain.className = 'card-name-main';
        
        const nameSub = document.createElement('div');
        nameSub.className = 'card-name-sub';
        
        const formattedName = formatCardName(card.name);
        nameMain.textContent = formattedName.main;
        nameSub.textContent = formattedName.sub;
        
        nameContainer.appendChild(nameMain);
        if (formattedName.sub) {
          nameContainer.appendChild(nameSub);
        }
        
        cardDiv.appendChild(nameContainer);

        // Stat sheet icon (crown)
        const statIcon = document.createElement('span');
        statIcon.className = 'stats-icon';
        statIcon.innerHTML = '&#x1F451;'; // crown emoji
        statIcon.title = 'View stats';
        statIcon.addEventListener('click', e => {
          e.stopPropagation();
          openStatsPopup(card);
        });
        cardDiv.appendChild(statIcon);

        cardDiv.addEventListener('click', () => {
          const firstEmpty = deck.findIndex(c => !c);
          if (firstEmpty !== -1) {
            deck[firstEmpty] = card;
            renderDeck();
            renderCards();
            updateSaveButton();
          }
        });

        cardDiv.addEventListener('dragstart', e => {
          e.dataTransfer.setData('type', 'card-list');
          e.dataTransfer.setData('cardKey', card.key);
          cardDiv.classList.add('dragging');
        });
        cardDiv.addEventListener('dragend', () => {
          cardDiv.classList.remove('dragging');
        });

        groupDiv.appendChild(cardDiv);
      });

      cardsListEl.appendChild(groupDiv);
    });
  }

  // Update Save button enable/disable based on deck & name
  function updateSaveButton() {
    const deckHasCards = deck.some(c => c !== null);
    const nameHasText = deckNameInput.value.trim().length > 0;
    saveBtn.disabled = !(deckHasCards && nameHasText);
  }

  function updateAverageElixir() {
    const cardsInDeck = deck.filter(c => c !== null);
    if (cardsInDeck.length === 0) {
      averageElixirDisplay.textContent = '';
      return;
    }
    const avg = (cardsInDeck.reduce((acc, c) => acc + c.elixir, 0) / cardsInDeck.length).toFixed(2);
    averageElixirDisplay.textContent = `Average Elixir Cost: ${avg}`;
  }

  // Open stats popup
  function openStatsPopup(card) {
    statsPopupImg.src = card.img;
    statsPopupImg.alt = card.name;
    statsPopupTitle.textContent = card.name;
    statsPopupDesc.textContent = card.stats;
    statsPopupElixir.textContent = card.elixir;
    statsPopupOverlay.style.display = 'flex';
  }
  statsPopupCloseBtn.addEventListener('click', () => {
    statsPopupOverlay.style.display = 'none';
  });
  statsPopupOverlay.addEventListener('click', (e) => {
    if (e.target === statsPopupOverlay) {
      statsPopupOverlay.style.display = 'none';
    }
  });

  // Save decks to localStorage
  function saveDecksToStorage() {
    localStorage.setItem('savedDecks', JSON.stringify(savedDecks));
  }

  // Render saved decks list
  function renderSavedDecks() {
    savedDecksContainer.innerHTML = '';
    savedDecks.forEach((deckObj, idx) => {
      const deckDiv = document.createElement('div');
      deckDiv.className = 'saved-deck';
      deckDiv.setAttribute('tabindex', '0');
      deckDiv.setAttribute('role', 'button');
      deckDiv.setAttribute('aria-label', `Load saved deck ${deckObj.name}`);

      // top row: name + (cards horizontal row)
      const topRow = document.createElement('div');
      topRow.className = 'saved-deck-top';

      const leftCol = document.createElement('div');
      leftCol.className = 'saved-deck-left';

      const nameDiv = document.createElement('div');
      nameDiv.className = 'saved-deck-name';
      nameDiv.textContent = deckObj.name;
      leftCol.appendChild(nameDiv);

      const cardsRow = document.createElement('div');
      cardsRow.className = 'saved-deck-cards-row';
      // Ensure we put all card images in a single horizontal row for the saved deck
      deckObj.cards.forEach(cardKey => {
        const cardData = cards.find(c => c.key === cardKey);
        if (!cardData) return;
        const img = document.createElement('img');
        img.src = cardData.img;
        img.alt = cardData.name;
        cardsRow.appendChild(img);
      });

      leftCol.appendChild(cardsRow);
      topRow.appendChild(leftCol);

      // right side of top row reserved for tower placeholder (kept minimal)
      const rightCol = document.createElement('div');
      rightCol.style.display = 'flex';
      rightCol.style.alignItems = 'center';
      rightCol.style.justifyContent = 'center';

      // We do not put the tower here anymore; user requested tower below the deck,
      // so keep the topRow compact and put tower below.
      topRow.appendChild(rightCol);

      deckDiv.appendChild(topRow);

      // tower below the card row: show the specific tower troop for this saved deck
      const towerRow = document.createElement('div');
      towerRow.className = 'saved-deck-tower';
      const towerLabel = document.createElement('div');
      towerLabel.style.fontSize = '12px';
      towerLabel.style.color = '#facc15';
      towerLabel.style.fontWeight = 'bold';
      towerLabel.textContent = 'Tower:';
      towerRow.appendChild(towerLabel);

      const towerImg = document.createElement('img');
      towerImg.className = 'tower-icon';
      if (deckObj.tower && towers[deckObj.tower]) {
        towerImg.src = towers[deckObj.tower].img;
        towerImg.alt = towers[deckObj.tower].name;
      } else {
        towerImg.src = '';
        towerImg.alt = 'No Tower';
      }
      towerRow.appendChild(towerImg);

      deckDiv.appendChild(towerRow);

      // Pencil icon for instant delete + load deck (preserve original functionality)
      const editBtn = document.createElement('button');
      editBtn.className = 'edit-deck-btn';
      editBtn.title = 'Delete deck and load it';
      editBtn.innerHTML = '&#9998;'; // pencil icon
      editBtn.addEventListener('click', e => {
        e.stopPropagation();
        // Delete deck immediately
        savedDecks.splice(idx, 1);
        saveDecksToStorage();
        renderSavedDecks();
        // Load deck cards into deck variable and deck name input
        deck = new Array(deckSlotsCount).fill(null);
        deckObj.cards.forEach((key, i) => {
          const c = cards.find(card => card.key === key);
          if (c) deck[i] = c;
        });
        deckNameInput.value = deckObj.name;
        // restore tower selection into select and the deck-side icon
        if (towerSelect) {
          if (deckObj.tower && towers[deckObj.tower]) {
            towerSelect.value = deckObj.tower;
            currentTowerIcon.src = towers[deckObj.tower].img;
            currentTowerIcon.alt = towers[deckObj.tower].name;
          } else {
            const optValue = towerSelect.value;
            if (towers[optValue]) {
              currentTowerIcon.src = towers[optValue].img;
              currentTowerIcon.alt = towers[optValue].name;
            } else {
              currentTowerIcon.src = '';
              currentTowerIcon.alt = 'Selected Tower';
            }
          }
        }
        renderDeck();
        renderCards();
        updateSaveButton();
      });
      deckDiv.appendChild(editBtn);

      // Delete button (preserve original)
      const delBtn = document.createElement('button');
      delBtn.className = 'delete-deck-btn';
      delBtn.title = 'Delete deck';
      delBtn.innerHTML = '&times;';
      delBtn.addEventListener('click', e => {
        e.stopPropagation();
        if (confirm(`Delete deck "${deckObj.name}"?`)) {
          savedDecks.splice(idx, 1);
          saveDecksToStorage();
          renderSavedDecks();
        }
      });
      deckDiv.appendChild(delBtn);

      // Click on saved deck loads it (preserve original)
      deckDiv.addEventListener('click', () => {
        deck = new Array(deckSlotsCount).fill(null);
        deckObj.cards.forEach((key, i) => {
          const c = cards.find(card => card.key === key);
          if (c) deck[i] = c;
        });
        deckNameInput.value = deckObj.name;
        // restore tower selection into select and the deck-side icon
        if (towerSelect) {
          if (deckObj.tower && towers[deckObj.tower]) {
            towerSelect.value = deckObj.tower;
            currentTowerIcon.src = towers[deckObj.tower].img;
            currentTowerIcon.alt = towers[deckObj.tower].name;
          } else {
            const optValue = towerSelect.value;
            if (towers[optValue]) {
              currentTowerIcon.src = towers[optValue].img;
              currentTowerIcon.alt = towers[optValue].name;
            } else {
              currentTowerIcon.src = '';
              currentTowerIcon.alt = 'Selected Tower';
            }
          }
        }
        renderDeck();
        renderCards();
        updateSaveButton();
      });

      savedDecksContainer.appendChild(deckDiv);
    });
  }

  // Check if deck with same cards and same first two cards (ignoring order) exists
  function isDuplicateDeck(newDeckCards) {
    if (newDeckCards.length !== deckSlotsCount) return false;
    const newCardsSorted = [...newDeckCards].filter(Boolean).map(c => c.key).sort();
    const newFirstTwo = newDeckCards.slice(0, 2).filter(Boolean).map(c => c.key);

    for (const saved of savedDecks) {
      if (saved.cards.length !== deckSlotsCount) continue;
      const savedCardsSorted = [...saved.cards].sort();
      const savedFirstTwo = saved.cards.slice(0, 2).filter(Boolean);

      if (arraysEqual(newCardsSorted, savedCardsSorted)) {
        if (newFirstTwo.length === savedFirstTwo.length &&
          newFirstTwo.every(c => savedFirstTwo.includes(c))) {
          return true;
        }
      }
    }
    return false;
  }

  // Utility function to check array equality
  function arraysEqual(a1, a2) {
    if (a1.length !== a2.length) return false;
    for (let i = 0; i < a1.length; i++) {
      if (a1[i] !== a2[i]) return false;
    }
    return true;
  }

  // Save form submit handler
  saveForm.addEventListener('submit', e => {
    e.preventDefault();
    const name = deckNameInput.value.trim();
    if (!name) return;

    // Check if deck name exists - no duplicates allowed
    if (savedDecks.some(d => d.name.toLowerCase() === name.toLowerCase())) {
      alert('A deck with this name already exists. Please choose a different name.');
      return;
    }

    if (deck.some(c => c === null)) {
      alert('Please fill all deck slots before saving.');
      return;
    }

    if (isDuplicateDeck(deck)) {
      alert('A deck with the same cards and same first two cards already exists.');
      return;
    }

    // Minimal addition: include tower selection (value) when saving
    const towerValue = (towerSelect && towerSelect.value) ? towerSelect.value : null;

    savedDecks.push({
      name: name,
      cards: deck.map(c => c.key),
      tower: towerValue
    });
    saveDecksToStorage();
    renderSavedDecks();
    deckNameInput.value = '';
    updateSaveButton();
    alert(`Deck "${name}" saved!`);
  });

  clearDeckBtn.addEventListener('click', () => {
    if (confirm('Clear the deck?')) {
      deck = new Array(deckSlotsCount).fill(null);
      renderDeck();
      renderCards();
      updateSaveButton();
    }
  });

  deckNameInput.addEventListener('input', updateSaveButton);

  // Update current deck-side tower icon when select changes (minimal behavior addition)
  if (towerSelect) {
    towerSelect.addEventListener('change', () => {
      const val = towerSelect.value;
      if (towers[val]) {
        currentTowerIcon.src = towers[val].img;
        currentTowerIcon.alt = towers[val].name;
      } else {
        currentTowerIcon.src = '';
        currentTowerIcon.alt = 'Selected Tower';
      }
    });
  }

  function init() {
    renderDeck();
    renderCards();
    renderSavedDecks();
    updateSaveButton();
  }

  init();
</script>

</body>
</html>
